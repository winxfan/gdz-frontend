Отлично — подготовил детальное техническое задание (ТЗ) для фронтенда: полностью на русском, 5 животных, имена + прилагательные — на русском, аватарки `avatar{index}.webp` (index 1..5). ТЗ охватывает архитектуру, API/контракты, логику детерминированного выбора по IP, примеры кода на TypeScript/React, требования к ассетам, доступность, тестирование и подсказки для генерации аватаров ИИ.

---

# Техническое задание: «Аватар-зверушка по IP»

## 1. Краткая цель

Показывать каждому пользователю персонализированную «зверушку» (аватар + имя) на основе IP-адреса. Для всех пользователей с одинаковым IP — один и тот же аватар и одно и то же имя. Набор животных — 5: **лиса, панда, енот, сова, пингвин**. Аватарки хранятся локально/на CDN как `avatar1.webp` … `avatar5.webp` (соответствуют порядку выше).

## 2. Требования

* Все прилагательные и названия животных — **на русском языке**.
* Имя пользователя = `{прилагательное} {животное}` (прилагательное согласовано по роду с именем животного).
* Аватар животного **должен совпадать с именем животного** (лиса → avatar1.webp и т.д.).
* Детерминированная формула: один и тот же IP → тот же результат.
* Лёгкая клиентская реализация (TS + React). Валидация и тесты.

## 3. Список животных (порядок и соответствие файлов)

1. `1` — лиса — `avatar1.webp` — род: женский
2. `2` — панда — `avatar2.webp` — род: женский
3. `3` — енот — `avatar3.webp` — род: мужской
4. `4` — сова — `avatar4.webp` — род: женский
5. `5` — пингвин — `avatar5.webp` — род: мужской

> Важно: индекс животного = `n % 5` плюс корректная трансляция в диапазон 1..5.

## 4. Словарь прилагательных (на русском)

Используем 15 прилагательных, для простоты храним формы для мужского и женского рода. Каждое прилагательное имеет две формы: `{masc, fem}`.

```ts
const adjectives = [
  { masc: "Любопытный", fem: "Любопытная" },
  { masc: "Тихий",      fem: "Тихая" },
  { masc: "Умный",      fem: "Умная" },
  { masc: "Яркий",      fem: "Яркая" },
  { masc: "Проворный",  fem: "Проворная" },
  { masc: "Смелый",     fem: "Смелая" },
  { masc: "Крошечный",  fem: "Крошечная" },
  { masc: "Везучий",    fem: "Везучая" },
  { masc: "Спокойный",  fem: "Спокойная" },
  { masc: "Мистический",fem: "Мистическая" },
  { masc: "Сонный",     fem: "Сонная" },
  { masc: "Благородный",fem: "Благородная" },
  { masc: "Космический",fem: "Космическая" },
  { masc: "Дружелюбный",fem: "Дружелюбная" },
  { masc: "Храбрый",    fem: "Храбрая" }
];
```

## 5. Алгоритм определения животного/имени по IP

### Правила

1. Преобразование IP (`A.B.C.D`) → число (детерминированно).
2. По этому числу получить индекс животного (0..4).
3. По этому числу (или сдвинутому варианту) получить индекс прилагательного (0..14).
4. Подставить прилагательное в нужной форме (по роду животного) + название животного (русское).
5. Сформировать путь к аватару `assets/avatars/avatar{index+1}.webp`.

### Предложенная реализация (TypeScript)

```ts
// constants.ts
export const animals = [
  { id: 1, key: "lisa", ru: "лиса", gender: "f" },
  { id: 2, key: "panda", ru: "панда", gender: "f" },
  { id: 3, key: "enot", ru: "енот", gender: "m" },
  { id: 4, key: "sova", ru: "сова", gender: "f" },
  { id: 5, key: "pingvin", ru: "пингвин", gender: "m" }
];

export const adjectives = [
  { masc: "Любопытный", fem: "Любопытная" },
  { masc: "Тихий",      fem: "Тихая" },
  { masc: "Умный",      fem: "Умная" },
  { masc: "Яркий",      fem: "Яркая" },
  { masc: "Проворный",  fem: "Проворная" },
  { masc: "Смелый",     fem: "Смелая" },
  { masc: "Крошечный",  fem: "Крошечная" },
  { masc: "Везучий",    fem: "Везучая" },
  { masc: "Спокойный",  fem: "Спокойная" },
  { masc: "Мистический",fem: "Мистическая" },
  { masc: "Сонный",     fem: "Сонная" },
  { masc: "Благородный",fem: "Благородная" },
  { masc: "Космический",fem: "Космическая" },
  { masc: "Дружелюбный",fem: "Дружелюбная" },
  { masc: "Храбрый",    fem: "Храбрая" }
];
```

```ts
// utils/ip.ts
export function ipToNumber(ip: string): number {
  // безопасно парсим IPv4; если невалидный — возвращаем 0
  if (!ip || typeof ip !== "string") return 0;
  const parts = ip.trim().split(".");
  if (parts.length !== 4) return 0;
  return parts.reduce((acc, p) => {
    const n = Number(p);
    if (!Number.isFinite(n) || n < 0) return acc;
    // 257 чтобы сбросить коллизии и чуть больше разброса
    return acc * 257 + Math.floor(n);
  }, 0);
}

export function getAvatarAndNameByIp(ip: string) {
  const n = ipToNumber(ip);
  const animalIndex = n % animals.length; // 0..4
  // сдвинаем битами, чтобы прилагательные были «разными»
  const adjIndex = (n >> 3) % adjectives.length; // 0..14

  const animal = animals[animalIndex];
  const adj = adjectives[adjIndex];

  const adjectiveForm = animal.gender === "f" ? adj.fem : adj.masc;
  const displayName = `${adjectiveForm} ${animal.ru}`;
  const avatarFile = `/assets/avatars/avatar${animal.id}.webp`; // индекс 1..5

  return {
    ip,
    animalKey: animal.key,
    animalRu: animal.ru,
    animalId: animal.id,
    gender: animal.gender,
    adjective: adjectiveForm,
    displayName,
    avatarFile
  };
}
```

**Примечания по безопасности/приватности:**

* Лучше вычислять `animalId`/`adjIndex` на сервере и отправлять клиенту только `animalId` и `displayName` или даже только `animalId` (чтобы клиент не имел доступа к IP).
* Если вычисляете на клиенте, не храните IP в localStorage в явном виде; вместо этого храните `hash(ip)` или только `animalId`.

## 6. API / контракт

Рассмотрим два варианта: сервер вычисляет или клиент вычисляет.

### Вариант A — Сервер возвращает `animalId` и `displayName`

**GET** `/api/avatar-info`
Ответ:

```json
{
  "animalId": 3,          // 1..5
  "animalRu": "енот",
  "displayName": "Дружелюбный енот",
  "avatarUrl": "/assets/avatars/avatar3.webp"
}
```

Преимущество: IP остаётся на сервере, клиент получает только результат.

### Вариант B — Сервер возвращает IP (не рекомендуется по приватности)

**GET** `/api/my-ip`
Ответ:

```json
{ "ip": "85.162.12.34" }
```

Клиент вычисляет сам `getAvatarAndNameByIp(ip)`. (Менее приватно.)

Рекомендация: использовать **Вариант A**.

## 7. Компонент React (пример)

```tsx
// AvatarBadge.tsx
import React from "react";

type Props = {
  avatarUrl: string;      // /assets/avatars/avatar{n}.webp
  displayName: string;    // "Любопытная лиса"
  size?: number;          // px, по умолчанию 48
};

export const AvatarBadge: React.FC<Props> = ({ avatarUrl, displayName, size = 48 }) => {
  return (
    <div className="avatar-badge" style={{ display: "flex", alignItems: "center", gap: 8 }}>
      <img
        src={avatarUrl}
        alt={displayName}
        width={size}
        height={size}
        style={{ borderRadius: "50%", display: "block", width: size, height: size }}
        loading="lazy"
      />
      <span aria-label={`Имя пользователя ${displayName}`} style={{ fontSize: 14 }}>
        {displayName}
      </span>
    </div>
  );
};
```

Пример получения данных (вариант A — сервер отдаёт `avatarUrl` и `displayName`):

```ts
// useAvatar.ts
import { useEffect, useState } from "react";

export function useAvatarInfo() {
  const [data, setData] = useState<{ avatarUrl: string; displayName: string } | null>(null);

  useEffect(() => {
    fetch("/api/avatar-info")
      .then((r) => r.json())
      .then((json) => {
        setData({ avatarUrl: json.avatarUrl, displayName: json.displayName });
      })
      .catch(() => {
        // фолбэк — статический аватар
        setData({ avatarUrl: "/assets/avatars/avatar1.webp", displayName: "Дружелюбная лиса" });
      });
  }, []);

  return data;
}
```

## 8. Ассеты (avatar files)

* Папка: `/assets/avatars/`
* Файлы: `avatar1.webp`, `avatar2.webp`, `avatar3.webp`, `avatar4.webp`, `avatar5.webp`
* Формат: PNG (или WebP для экономии трафика), прозрачный фон, круги/иконки одного стиля. Рекомендуемый размер: 512×512 px (для генерации), на продакшн — 128×128, 64×64 и 32×32 версии (ретина/адаптивность).

## 9. Генерация аватаров ИИ — промпты (на русском)

Ниже — промпты для генерации единого стильного набора (каждый промпт менять только `{ЖИВОТНОЕ}` и `avatar{index}.webp` в метаданных при сохранении).

**Общий стиль:** мультяшный, минимализм, плоские цвета, плавные формы, дружелюбный вид, без фона, круговая компоновка.

### Базовый промпт (русский)

```
Создай милый минималистичный векторный аватар {ЖИВОТНОЕ} в едином стиле для набора пользовательских иконок.
Требования:
- Стиль: плоский, округлые формы, минимальные детали, мультяшный.
- Выражение: дружелюбное, нейтрально-позитивное.
- Фон: прозрачный (no background).
- Композиция: круг (иконка внутри круга), чтобы край животного не выходил за границу.
- Форматы: PNG и WebP, размер исходника 1024×1024 px.
- Цветовая палитра: 2–3 плоских цвета, контрастная, чтобы иконки легко распознавались в 32×32.
- Сохранить файл как: avatar{index}.webp
```

### Примеры для каждого животного (вставлять вместо `{ЖИВОТНОЕ}`)

* для `avatar1.webp`: `{ЖИВОТНОЕ} = лиса`
* для `avatar2.webp`: `{ЖИВОТНОЕ} = панда`
* для `avatar3.webp`: `{ЖИВОТНОЕ} = енот`
* для `avatar4.webp`: `{ЖИВОТНОЕ} = сова`
* для `avatar5.webp`: `{ЖИВОТНОЕ} = пингвин`

> Рекомендация: при генерации указывать «consistent style for a pack of 5 avatars» (или на русском «единый стиль для набора из 5 аватарок») и использовать одинаковые правила освещения/толщи линий/округлости.

## 10. UX / UI детали

* Показывать аватар рядом с именем пользователя в хедере/профиле/списках.
* По hover — показывать `title` с полным `displayName`.
* Аватар + имя должны быть локализованы (русский).
* При отсутствии соединения или ошибке — показывать дефолтную иконку и `displayName` = `Гость`.

## 11. Кеширование и производительность

* Предзагрузить 5 маленьких аватаров на страницу: `<link rel="preload" as="image" href="/assets/avatars/avatar1.webp">` и т.д.
* Кешировать ответ `/api/avatar-info` в `localStorage` вместе с меткой времени (TTL, например, 24 часа), чтобы не запрашивать постоянно.
* Не хранить сам IP в `localStorage`; хранить только `animalId` и `displayName`.

## 12. Обработка частных/локальных IP (пример)

* Если IP — локальный (например, `127.0.0.1`, `10.x.x.x`, `192.168.x.x`) или невалидный, возвращать предсказуемый fallback (например, `avatar1.webp` — лиса), либо вычислять по хэшу client-generated id.

## 13. Тесты

* Unit tests:

  * `ipToNumber` корректно парсит типичные IP и генерирует детерминированное число.
  * `getAvatarAndNameByIp` возвращает ожидаемые `animalId` для наборов тестовых IPs. (Прописать примеры: `8.8.8.8`, `127.0.0.1` и др.)
  * Согласование прилагательного по роду.
* Integration tests:

  * Эндпоинт `/api/avatar-info` возвращает корректную структуру.
  * Компонент `AvatarBadge` рендерит изображение с правильным `alt`.
* Visual tests:

  * Перекрестная проверка: avatarX.webp соответствует animalRu.

## 14. Доступность (a11y)

* `img` должен иметь `alt` равный `displayName`.
* При использовании `aria-label` — включить `aria-label="Пользователь: {displayName}"`.
* Размеры шрифта и контраст — соответствовать WCAG AA для текста рядом с аватаром.

## 15. Логирование / аналитика

* Не логировать IP на фронте.
* Сервер может логировать `animalId` (без IP) для аналитики — количество уникальных animalId. Если требуется GDPR/законы о приватности — получать согласие.

## 16. Localization / i18n

* Все строки (прилагательные, названия животных) — в i18n-ресурсе (например, `ru.json`), чтобы при будущем переходе на другие языки можно было добавить перевод.
* Пример `ru.json`:

```json
{
  "animals": {
    "lisa": "лиса",
    "panda": "панда",
    "enot": "енот",
    "sova": "сова",
    "pingvin": "пингвин"
  }
}
```

## 17. CI / Deployment

* Проверки: unit tests + lint.
* При билде ассеты должны копироваться в `public/assets/avatars/`.
* Версионируй аватарки (например `avatar1.v1.webp`) если планируешь пересоздавать.

## 18. Пример набора тестовых IP → результатов (для QA)

* `8.8.8.8` → (пример) `avatar3.webp`, `Дружелюбный енот`
* `1.2.3.4` → `avatar2.webp`, `Тихая панда`
  (эти соответствия зависят от реализации `ipToNumber` — в тестах нужно зафиксировать ожидаемые значения.)

## 19. Доп. фичи (опционально)

* Возможность переопределить аватар вручную в профиле (если пользователь хочет другой). В этом случае сохранять пользовательский выбор и показывать его вместо IP-генерированного.
* Поддержка темы (dark/light) — альтернативные палитры аватаров.
* Анимированные версии (GIF/WebM) для премиум-пользователей.

---

# Быстрая инструкция реализации (шаги)

1. Подготовить и положить в `public/assets/avatars/` файлы `avatar1.webp`…`avatar5.webp`.
2. Добавить `constants.ts` (animals + adjectives).
3. Реализовать `utils/ip.ts` с `ipToNumber` и `getAvatarAndNameByIp`.
4. Реализовать серверный эндпоинт `/api/avatar-info`, который вычисляет (на сервере) `animalId` и `displayName` по реальному IP клиента и возвращает `avatarUrl`.

   * сервер: чтение IP через `X-Forwarded-For` или `req.socket.remoteAddress`.
5. На фронте: hook `useAvatarInfo` для получения `/api/avatar-info`.
6. Рендер компонента `AvatarBadge`.
7. Написать unit tests.
8. Деплой и мониторинг.

---

Если хочешь — могу прямо сейчас:

* Сгенерировать `ru.json` с полным маппингом (animals + прилагательные).
* Прописать набор unit-test'ов (Jest) для `ipToNumber` и `getAvatarAndNameByIp`.
* Сформировать готовые промпты для каждого avatarN на русском (подробнее, с вариантами палитр и референсами).

Что делаем дальше — генерируем тесты, `ru.json` или промпты для AI-генерации аватаров?


Есть два вида пользователей - anon user и authorized user
По умолчанию у пользователя статус anon userAuthorized user пользователь получает такой статус когда авторизуется через социальную сеть

Anon user
- Идентифицируется по ip адресу, на сервер отправляется запрос /auth-anon с ip адресом -> возвращается ip адрес
- Получает бесплатные 5 токенов
- Показывается аватар + сгенерированное имя как в гугл (например Доблесный опоссум)
- Ip адрес всегда шифруется через md5, полученная информация о пользователе из сервера сохраняется в cookie
- Нельзя позволить чтобы анонимный пользователь мог использовать бесплатные токены путем обновления страницы, сменой браузера и так далее
- При первом заходе на сайт - идет запрос на бэкенд с зашифрованным ip адресом для получения информации о пользователе
- У анонимного пользователя 5 токенов которые он может потратить, при этом только 2 токена он может потратить в статусе анонимного пользователя, далее выскакивает окно авторизации для получения доступа к остальным токенам


Authorized user
- Главное отличие от анонимного пользователя то что запросы от этого пользователя идут по id пользователя вместо ip

Если у пользователя нет токенов - открывается модальное окно с предложением пополнить баланс
Авторизация доступна через oauth сервисы - vk id, yandex, google